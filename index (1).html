<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mexicana Paddle Tournament</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#121212" />
  <style>
    /* Spotify-inspired dark UI, mobile-first */
    :root {
      --bg: #121212;
      --elev-1: #181818;
      --elev-2: #1f1f1f;
      --surface: #0f0f0f;
      --text: #ffffff;
      --muted: #b3b3b3;
      --accent: #1db954;
      --accent-2: #19a14a;
      --danger: #ff5c5c;
      --warn: #ffcc66;
      --ok: #7ee787;
      --border: #2a2a2a;
      --focus: #3be477;
      --shadow: 0 10px 24px rgba(0,0,0,0.35);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 70% -10%, rgba(29,185,84,0.08), transparent 60%) , var(--bg);
      color: var(--text);
      font: 16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
    }

    header {
      position: sticky; top: 0; z-index: 50;
      backdrop-filter: blur(10px);
      background: rgba(18,18,18,0.8);
      border-bottom: 1px solid var(--border);
    }
    .container {
      margin: 0 auto; width: 100%;
      padding: 12px 14px;
      max-width: 1000px;
    }
    .brand {
      display: flex; align-items: center; gap: 10px;
    }
    .logo {
      width: 28px; height: 28px; border-radius: 6px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 0 0 4px rgba(29,185,84,0.15);
    }
    h1 { margin: 0; font-size: 20px; letter-spacing: 0.2px; }

    main.container { padding-top: 16px; padding-bottom: 28px; }

    /* Cards and layout */
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .card {
      background: linear-gradient(180deg, var(--elev-1), var(--elev-2));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    @media (min-width: 960px) {
      .grid { grid-template-columns: 1fr 2fr; }
    }

    h2 { margin: 2px 0 12px; font-size: 18px; color: var(--text); }
    h3 { margin: 8px 0 10px; font-size: 16px; color: var(--muted); }

    /* Inputs */
    input, button, select {
      border: 1px solid var(--border);
      background: #0d0d0d;
      color: var(--text);
      padding: 12px 12px;
      font-size: 16px;
      border-radius: 12px;
      outline: none;
      width: 100%;
    }
    input::placeholder { color: #6b7280; }
    .btn {
      background: linear-gradient(180deg, #0e1a12, #0a150e);
      border-color: #1b3b27;
      cursor: pointer;
      transition: transform .05s ease, filter .2s ease, box-shadow .2s ease;
      text-align: center;
      font-weight: 600;
    }
    .btn:hover { filter: brightness(1.06); }
    .btn:active { transform: translateY(1px); }
    .btn-accent {
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      color: #081b0f;
      border-color: #126b33;
    }
    .btn-ghost {
      background: #121212;
      border-color: var(--border);
      color: var(--text);
    }
    .btn-warn {
      background: linear-gradient(180deg, #2a210f, #201a0c);
      border-color: #5b4a23;
      color: #ffe8b0;
    }
    .btn-danger {
      background: linear-gradient(180deg, #2a1414, #1d0e0e);
      border-color: #5b2323;
      color: #ffd7d7;
    }

    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .col { display: flex; flex-direction: column; gap: 10px; }
    .small { font-size: 12px; color: var(--muted); }
    .muted { color: var(--muted); }
    .spacer { flex: 1; }
    .kbd { border: 1px solid var(--border); background: #0c0c0c; padding: 0 6px; border-radius: 6px; font-size: 12px; }

    .input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; }
    @media (min-width: 560px) {
      .input-group { grid-template-columns: 1fr auto; }
    }

    /* Teams and matches */
    .teams { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 560px) {
      .teams { grid-template-columns: repeat(2, 1fr); }
    }
    @media (min-width: 960px) {
      .teams { grid-template-columns: repeat(3, 1fr); }
    }
    .team {
      background: #141414;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }
    .team .meta { display: flex; justify-content: space-between; color: var(--muted); font-size: 12px; margin-bottom: 6px; }
    .player { display: flex; justify-content: space-between; gap: 8px; }
    .player span.name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .player span.r { color: var(--muted); font-size: 12px; }

    .list { display: grid; gap: 10px; }
    .match {
      background: #141414;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }

    .vs { color: var(--muted); padding: 0 6px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .result { display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-top: 8px; }
    .applied { color: var(--ok); font-size: 12px; }

    /* Standings */
    .table { width: 100%; border-collapse: collapse; }
    .table th, .table td { padding: 10px 8px; border-bottom: 1px dashed #2a2a2a; text-align: left; }
    .table th { color: var(--muted); font-weight: 600; }
    .right { text-align: right; }
    .winner { color: var(--ok); }
    .loser { color: var(--danger); }

    .hr { height: 1px; background: #232323; margin: 10px 0; }

    /* Toast */
    .toast {
      position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
      background: #111; color: #e5e7eb; padding: 10px 14px; border-radius: 10px;
      border: 1px solid #333; box-shadow: var(--shadow);
      font-size: 14px; z-index: 9999; opacity: 0; transition: opacity .25s ease;
    }
    .toast.show { opacity: 1; }

    /* Focus and a11y */
    :focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }
    a { color: #a7ffcc; }
  </style>
</head>
<body>
  <header>
    <div class="container row" style="justify-content: space-between;">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <h1>Mexicana Paddle</h1>
      </div>
      <div class="row" role="toolbar" aria-label="Actions">
        <!-- Removed export/import/reset/k-factor per request -->
        <button id="nextRound" class="btn btn-accent">New Round</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="grid">
      <section class="card">
        <h2>Players</h2>
        <div class="input-group" style="margin-bottom:8px;">
          <input id="playerName" placeholder="Add player full name" autocomplete="off"/>
          <button id="addPlayer" class="btn btn-ghost">Add</button>
        </div>
        <div class="row">
          <div class="col" style="flex:1;">
            <span class="small">Start rating</span>
            <input id="startRating" type="number" value="1000" inputmode="numeric" pattern="[0-9]*"/>
          </div>
          <div class="col" style="flex:1;">
            <span class="small">Round</span>
            <div class="row" style="gap:6px;">
              <span id="roundTag" class="small" style="padding:8px 10px; border:1px solid var(--border); border-radius:10px; background:#101010;">Round 0</span>
              <button id="shuffleTeams" class="btn">Create Teams</button>
            </div>
          </div>
        </div>
        <div class="hr"></div>
        <div id="playersList" class="list"></div>
        <div class="hr"></div>
        <div class="row">
          <button id="clearScores" class="btn btn-warn">Clear Pending Scores</button>
          <button id="applyResults" class="btn">Apply Results</button>
          <button id="undoLast" class="btn btn-danger">Undo Last Apply</button>
        </div>
        <p class="small">Tips: press <span class="kbd">/</span> to focus result input, and <span class="kbd">Enter</span> to save.</p>
      </section>

      <section class="card">
        <h2>Current Round</h2>
        <div id="teamsWrap" class="teams"></div>
        <div class="hr"></div>
        <h3>Matches</h3>
        <div id="matchesWrap" class="list"></div>
      </section>
    </div>

    <section class="card" style="margin-top:12px;">
      <h2>Standings</h2>
      <table class="table" id="standingsTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Player</th>
            <th class="right">Rating</th>
            <th class="right">W L</th>
            <th class="right">Points ±</th>
            <th class="right">Sets</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </main>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    // ======= State =======
    const LS_KEY = "mexicana_state_v2"; // new key to avoid clashing with old layout
    let state = loadState() || {
      players: [],
      rounds: [],
      lastApplied: [],
      startRating: 1000,
      round: 0
    };

    // ======= Elements =======
    const el = {
      playerName: document.getElementById("playerName"),
      addPlayer: document.getElementById("addPlayer"),
      playersList: document.getElementById("playersList"),
      shuffleTeams: document.getElementById("shuffleTeams"),
      nextRound: document.getElementById("nextRound"),
      clearScores: document.getElementById("clearScores"),
      applyResults: document.getElementById("applyResults"),
      undoLast: document.getElementById("undoLast"),
      teamsWrap: document.getElementById("teamsWrap"),
      matchesWrap: document.getElementById("matchesWrap"),
      roundTag: document.getElementById("roundTag"),
      startRating: document.getElementById("startRating"),
      standingsTable: document.getElementById("standingsTable").querySelector("tbody"),
      toast: document.getElementById("toast"),
    };

    // ======= Utils =======
    const uid = () => Math.random().toString(36).slice(2, 10);
    function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function loadState(){ try { return JSON.parse(localStorage.getItem(LS_KEY) || ""); } catch { return null; } }
    function toast(msg){ el.toast.textContent = msg; el.toast.classList.add("show"); setTimeout(()=>el.toast.classList.remove("show"), 1700); }
    function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

    // ======= Core logic =======
    function addPlayer(name){
      name = (name || "").trim();
      if(!name){ toast("Name required"); return; }
      if(state.players.some(p => p.name.toLowerCase() === name.toLowerCase())){ toast("Duplicate name"); return; }
      const p = { id: uid(), name, rating: Number(state.startRating)||1000, wins:0, losses:0, pointsFor:0, pointsAgainst:0 };
      state.players.push(p);
      saveState(); renderAll(); toast("Player added");
      el.playerName.value = "";
    }
    function removePlayer(id){
      const pending = currentRound()?.matches.some(m => !m.applied && (m.a.includes(id) || m.b.includes(id)));
      if(pending){ toast("Cannot remove: player in pending match"); return; }
      state.players = state.players.filter(p => p.id !== id);
      saveState(); renderAll(); toast("Player removed");
    }

    // Mexicana pairing: sort by rating, pair top with bottom
    function pairTeamsMexicana(playerList){
      const players = deepClone(playerList).sort((a,b)=>b.rating - a.rating);
      const ids = players.map(p=>p.id);
      const teams = [];
      const n = ids.length;
      if(n < 4){ return teams; }
      const half = Math.floor(n/2);
      const top = ids.slice(0, half);
      const bottom = ids.slice(n - half).reverse();
      for(let i=0;i<half;i++){ teams.push([top[i], bottom[i]]); }
      if(n % 2 === 1){ toast("Odd count: one player will sit out this round"); }
      return teams;
    }

    // One match per team in each round: adjacent pairs only
    function scheduleOneMatchPerTeam(teams){
      const matches = [];
      for(let i=0;i+1<teams.length;i+=2){
        matches.push({ id: uid(), a: teams[i], b: teams[i+1], scoreA:null, scoreB:null, applied:false });
      }
      if(teams.length % 2 === 1){
        // Last team sits out if odd number of teams
        toast("Odd team count: one team sits out");
      }
      return matches;
    }

    function newRound(){
      if(state.players.length < 4){ toast("Add at least 4 players"); return; }
      const teams = pairTeamsMexicana(state.players);
      if(teams.length === 0){ toast("Not enough players for teams"); return; }
      const matches = scheduleOneMatchPerTeam(teams);
      state.round += 1;
      const rnd = { id: uid(), index: state.round, teams, matches };
      state.rounds.push(rnd);
      saveState(); renderAll(); toast("New round created");
    }

    function currentRound(){
      if(state.rounds.length === 0) return null;
      return state.rounds[state.rounds.length-1];
    }

    // Score parsing N:N
    function parseScore(text){
      if(typeof text !== "string") return null;
      const m = text.trim().match(/^(\d+)\s*[:\-]\s*(\d+)$/);
      if(!m) return null;
      return [parseInt(m[1],10), parseInt(m[2],10)];
    }

    function expectedScore(ra, rb){ return 1 / (1 + Math.pow(10, (rb - ra) / 400)); }

    function applyMatchResult(match, scoreA, scoreB){
      if(match.applied){ return null; }
      const teamA = match.a.map(id => state.players.find(p=>p.id===id));
      const teamB = match.b.map(id => state.players.find(p=>p.id===id));
      if(teamA.includes(undefined) || teamB.includes(undefined)){ return null; }

      const avgA = (teamA[0].rating + teamA[1].rating)/2;
      const avgB = (teamB[0].rating + teamB[1].rating)/2;

      const expA = expectedScore(avgA, avgB);
      const sA = scoreA > scoreB ? 1 : (scoreA === scoreB ? 0.5 : 0);
      const sB = 1 - sA;

      // Fixed K for simplicity since K-factor control was removed
      const K = 24;
      const diff = Math.abs(scoreA - scoreB);
      const margin = Math.log(diff + 1);
      const kScaled = K * (1 + margin * 0.5);

      const deltaA = kScaled * (sA - expA);
      const deltaB = -deltaA;

      const perA = deltaA / 2;
      const perB = deltaB / 2;

      const changes = { matchId: match.id, deltaByPlayer: {} };

      teamA.forEach(p=>{
        p.rating = Math.round(p.rating + perA);
        if(sA === 1) p.wins++; else if(sA === 0) p.losses++;
        p.pointsFor += scoreA; p.pointsAgainst += scoreB;
        changes.deltaByPlayer[p.id] = (changes.deltaByPlayer[p.id]||0) + perA;
      });
      teamB.forEach(p=>{
        p.rating = Math.round(p.rating + perB);
        if(sB === 1) p.wins++; else if(sB === 0) p.losses++;
        p.pointsFor += scoreB; p.pointsAgainst += scoreA;
        changes.deltaByPlayer[p.id] = (changes.deltaByPlayer[p.id]||0) + perB;
      });

      match.scoreA = scoreA; match.scoreB = scoreB; match.applied = true;
      return changes;
    }

    function applyAllEntered(){
      const rnd = currentRound();
      if(!rnd){ toast("No current round"); return; }
      let applied = 0;
      const batch = [];
      for(const m of rnd.matches){
        const input = document.getElementById("score_"+m.id);
        if(!input) continue;
        const parsed = parseScore(input.value);
        if(!parsed) continue;
        if(m.applied) continue;
        const changes = applyMatchResult(m, parsed[0], parsed[1]);
        if(changes){ batch.push(changes); applied++; }
      }
      if(applied === 0){ toast("No new results to apply"); return; }
      state.lastApplied = batch;
      saveState(); renderAll(); toast("Applied "+applied+" result(s)");
    }

    function undoLastApplied(){
      if(!state.lastApplied || state.lastApplied.length === 0){ toast("Nothing to undo"); return; }
      const rnd = currentRound();
      const matchById = {};
      if(rnd){ rnd.matches.forEach(m=>matchById[m.id]=m); }
      for(const change of state.lastApplied){
        const m = matchById[change.matchId];
        if(m){ m.applied = false; m.scoreA = null; m.scoreB = null; }
        for(const pid in change.deltaByPlayer){
          const p = state.players.find(pp=>pp.id===pid);
          if(!p) continue;
          const delta = change.deltaByPlayer[pid];
          p.rating = Math.round(p.rating - delta);
        }
      }
      // Recompute W/L and points from applied matches for consistency
      recomputeAggregates();
      state.lastApplied = [];
      saveState(); renderAll(); toast("Undone");
    }

    function recomputeAggregates(){
      state.players.forEach(p=>{ p.wins=0; p.losses=0; p.pointsFor=0; p.pointsAgainst=0; p.rating = Number(state.startRating)||1000; });
      const all = [];
      for(const rnd of state.rounds){ for(const m of rnd.matches){ if(m.applied) all.push({rnd, m}); } }
      all.sort((a,b)=>a.rnd.index - b.rnd.index);
      for(const {m} of all){
        const teamA = m.a.map(id => state.players.find(p=>p.id===id));
        const teamB = m.b.map(id => state.players.find(p=>p.id===id));
        const avgA = (teamA[0].rating + teamA[1].rating)/2;
        const avgB = (teamB[0].rating + teamB[1].rating)/2;
        const expA = expectedScore(avgA, avgB);
        const sA = m.scoreA > m.scoreB ? 1 : (m.scoreA === m.scoreB ? 0.5 : 0);
        const sB = 1 - sA;
        const K = 24;
        const diff = Math.abs(m.scoreA - m.scoreB);
        const margin = Math.log(diff + 1);
        const kScaled = K * (1 + margin * 0.5);
        const deltaA = kScaled * (sA - expA);
        const deltaB = -deltaA;
        const perA = deltaA / 2;
        const perB = deltaB / 2;
        teamA.forEach(p=>{ p.rating = Math.round(p.rating + perA); if(sA===1)p.wins++; else if(sA===0)p.losses++; p.pointsFor += m.scoreA; p.pointsAgainst += m.scoreB; });
        teamB.forEach(p=>{ p.rating = Math.round(p.rating + perB); if(sB===1)p.wins++; else if(sB===0)p.losses++; p.pointsFor += m.scoreB; p.pointsAgainst += m.scoreA; });
      }
    }

    // ======= Rendering =======
    function renderPlayers(){
      const list = el.playersList;
      list.innerHTML = "";
      const sorted = [...state.players].sort((a,b)=>b.rating - a.rating);
      for(const p of sorted){
        const item = document.createElement("div");
        item.className = "row";
        item.style.justifyContent = "space-between";
        const left = document.createElement("div");
        left.className = "row";
        left.style.flex = "1";
        const name = document.createElement("div");
        name.textContent = p.name;
        name.style.fontWeight = "600";
        const meta = document.createElement("div");
        meta.className = "small muted";
        meta.textContent = "R " + p.rating + " • W" + p.wins + "-L" + p.losses + " • ±" + (p.pointsFor - p.pointsAgainst);
        left.append(name, meta);
        const del = document.createElement("button");
        del.textContent = "Remove";
        del.className = "btn btn-danger";
        del.onclick = ()=>removePlayer(p.id);
        item.append(left, del);
        list.appendChild(item);
      }
    }

    function renderTeamsAndMatches(){
      const rnd = currentRound();
      el.roundTag.textContent = "Round " + state.round;
      el.teamsWrap.innerHTML = "";
      el.matchesWrap.innerHTML = "";
      if(!rnd){
        el.teamsWrap.innerHTML = "<div class='muted'>No round yet. Create teams to start.</div>";
        return;
      }
      rnd.teams.forEach((t, idx)=>{
        const pa = state.players.find(p=>p.id===t[0]);
        const pb = state.players.find(p=>p.id===t[1]);
        const avg = Math.round((pa.rating + pb.rating)/2);
        const div = document.createElement("div");
        div.className = "team";
        div.innerHTML = `
          <div class="meta"><span>Team ${idx+1}</span><span>Avg ${avg}</span></div>
          <div class="player"><span class="name">${pa.name}</span><span class="r">R ${pa.rating}</span></div>
          <div class="player"><span class="name">${pb.name}</span><span class="r">R ${pb.rating}</span></div>
        `;
        el.teamsWrap.appendChild(div);
      });

      const wrap = document.createElement("div");
      wrap.className = "list";
      rnd.matches.forEach((m, i)=>{
        const a0 = state.players.find(p=>p.id===m.a[0]).name;
        const a1 = state.players.find(p=>p.id===m.a[1]).name;
        const b0 = state.players.find(p=>p.id===m.b[0]).name;
        const b1 = state.players.find(p=>p.id===m.b[1]).name;
        const scoreText = m.scoreA!=null? (m.scoreA+":"+m.scoreB) : "";
        const card = document.createElement("div");
        card.className = "match";
        card.innerHTML = `
          <div class="row" style="justify-content: space-between;">
            <div class="small muted">Match ${i+1}</div>
            <div class="applied">${m.applied ? "applied" : ""}</div>
          </div>
          <div class="row" style="flex-wrap:nowrap; overflow:hidden;">
            <div style="flex:1; min-width:0;"><span class="mono" style="font-weight:600;">${a0}</span> + <span class="mono" style="font-weight:600;">${a1}</span></div>
            <div class="vs">vs</div>
            <div style="flex:1; min-width:0; text-align:right;"><span class="mono" style="font-weight:600;">${b0}</span> + <span class="mono" style="font-weight:600;">${b1}</span></div>
          </div>
          <div class="result">
            <input id="score_${m.id}" class="mono" placeholder="e.g. 12:14" value="${scoreText}" inputmode="numeric" />
            <button class="btn btn-accent" id="save_${m.id}">Save</button>
          </div>
        `;
        wrap.appendChild(card);
        setTimeout(()=>{
          const scoreInput = document.getElementById("score_"+m.id);
          const saveBtn = document.getElementById("save_"+m.id);
          saveBtn.onclick = ()=>{
            const parsed = parseScore(scoreInput.value);
            if(!parsed){ toast("Invalid score, use N:N"); return; }
            if(m.applied){ toast("Already applied"); return; }
            m.scoreA = parsed[0]; m.scoreB = parsed[1];
            saveState(); renderTeamsAndMatches(); toast("Saved");
          };
        },0);
      });
      el.matchesWrap.appendChild(wrap);
    }

    function renderStandings(){
      const tbody = el.standingsTable;
      tbody.innerHTML = "";
      const rows = [...state.players].sort((a,b)=>b.rating - a.rating);
      rows.forEach((p, idx)=>{
        const tr = document.createElement("tr");
        const diff = p.pointsFor - p.pointsAgainst;
        tr.innerHTML = `
          <td class="mono">${idx+1}</td>
          <td>${p.name}</td>
          <td class="right mono">${p.rating}</td>
          <td class="right mono">${p.wins} ${p.losses}</td>
          <td class="right mono ${diff>=0?'winner':'loser'}">${diff>=0?'+':''}${diff}</td>
          <td class="right mono">${p.pointsFor}:${p.pointsAgainst}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renderAll(){
      el.startRating.value = state.startRating;
      renderPlayers();
      renderTeamsAndMatches();
      renderStandings();
    }

    // ======= Events =======
    el.addPlayer.onclick = ()=>addPlayer(el.playerName.value);
    el.playerName.addEventListener("keydown", e=>{ if(e.key==="Enter"){ addPlayer(el.playerName.value); }});
    el.shuffleTeams.onclick = newRound;
    el.nextRound.onclick = newRound;
    el.applyResults.onclick = applyAllEntered;
    el.undoLast.onclick = undoLastApplied;
    el.clearScores.onclick = ()=>{
      const rnd = currentRound();
      if(!rnd){ toast("No round"); return; }
      rnd.matches.forEach(m=>{ if(!m.applied){ m.scoreA=null; m.scoreB=null; } });
      saveState(); renderTeamsAndMatches(); toast("Cleared");
    };
    el.startRating.onchange = ()=>{ state.startRating = Number(el.startRating.value)||1000; saveState(); toast("Start rating updated"); };

    // Keyboard UX
    document.addEventListener("keydown", (e)=>{
      if(e.key === "/"){
        e.preventDefault();
        const inputs = Array.from(document.querySelectorAll('input[id^="score_"]'));
        const target = inputs.find(inp => !inp.value) || inputs[0];
        if(target){ target.focus(); }
      }
      if(e.key === "Enter"){
        const active = document.activeElement;
        if(active && active.id && active.id.startsWith("score_")){
          const id = active.id.replace("score_", "");
          const btn = document.getElementById("save_"+id);
          if(btn){ btn.click(); }
        }
      }
    });

    // Initial render
    renderAll();
  </script>
</body>
</html>
